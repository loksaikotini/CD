1. Write a C program to design a lexical analyzer that recognizes identifiers and keywords of flow control statements of C language




#include <stdio.h>
#include <ctype.h>
#include <conio.h>
#include <string.h>
void main()
{
    int i, flag = 0;
    char str[50];


  
    printf("Enter string\n");
    scanf("%s", str);


    // Check for control-flow keywords
    if ((strcmp(str, "if") == 0) || (strcmp(str, "else") == 0) ||
        (strcmp(str, "do") == 0) || (strcmp(str, "for") == 0) ||
        (strcmp(str, "break") == 0) || (strcmp(str, "while") == 0) ||
        (strcmp(str, "switch") == 0) || (strcmp(str, "case") == 0) ||
        (strcmp(str, "default") == 0))
    {
        printf("Keyword of control flow statements");
    }
    else if (isalpha(str[0]) && strlen(str) < 32)   // identifier check
    {
        flag = 0;
        for (i = 1; i < strlen(str); i++)
        {
            if (isalnum(str[i]) || str[i] == '_')
                continue;
            else
            {
                flag = 1;
                break;
            }
        }


        if (flag == 0)
            printf("Identifier");
        else
            printf("Not a keyword or identifier");
    }
    else
    {
        printf("Not a keyword or identifier");
    }


    getch();
}




Output 1:
  Enter string : if (a>b) return true
Keyword of control flow statements
Output 2:
enter string
for
keyword of control flow statements
Output 3:
enter string
2dfdgfh
not a keyword or identifier


 
10. Write a Lex specification to design a lexical analyzer that recognizes identifiers and keywords of flow control statements of C language
%{
    #include <stdio.h>
%}


%%


/* Flow-control keywords (case-insensitive using | ) */
if|else|while|do|switch|case|break|for|default
|IF|ELSE|WHILE|DO|SWITCH|CASE|BREAK|FOR|DEFAULT     { printf("Keyword\n"); }


/* Identifier rule */
[A-Za-z_][A-Za-z0-9_]*                               { printf("identifier\n"); }


/* Ignore spaces, tabs, newlines */
[ \t\n]+                                             { /* skip */ }


/* Anything else is invalid */
.                                                    { printf("invalid\n"); }


%%


int main()
{
    yylex();
    return 0;
}
Compilation: lex lexanalysis.l
                            cc lex.yy.c -ll
                            ./a.out
                            If
                            Keyword
                            FOR
                            Keyword
                            Abc123_def
                            identifier






2. Write a C program to construct Recursive Descent parser for the following grammar
E->TR
R->+TR/Î
T->FP
P->*FP/Î
F->a/(E)










#include<stdio.h>
#include<conio.h>
#include<stdlib.h>


void E();
void R();
void P();
void T();
void F();
void error();


char str[20];
int ip = 0;


void main()
{
    
    printf("Enter string (ending with $):\n");
    scanf("%s", str);


    E();


    if (str[ip] == '$')
        printf("Parsing is successful");
    else
        printf("Parsing failed");


    getch();
}


void E()
{
    T();
    R();
}


void R()
{
    if (str[ip] == '+')
    {
        ip++;
        T();
        R();
    }
    // epsilon production
}


void T()
{
    F();
    P();
}


void P()
{
    if (str[ip] == '*')
    {
        ip++;
        F();
        P();
    }
    // epsilon production
}


void F()
{
    if (str[ip] == '(')
    {
        ip++;
        E();
        if (str[ip] == ')')
            ip++;
        else
        {
            printf("Missing )\n");
            exit(0);
        }
    }
    else if (str[ip] == 'a')
    {
        ip++;
    }
    else
    {
        error();
    }
}


void error()
{
    printf("Error occurred during parsing\n");
    exit(0);
}


OUTPUT:
Enter string (ending with $):
a+a*a$
Parsing is successful










. Write recursive descent parser for the grammar E->E+T           E->T                                T->T*F                 T->F      F->(E)/id.       (This grammar is left recursive, so we cannot implement a recursive-descent parser directly.)


E  → T E'  E' → + T E' | ε  T  → F T'  T' → * F T' | ε  F  → (E) | id






#include <stdio.h>                                     
#include <ctype.h>


char input[100];
int i = 0;


void E();
void Eprime();
void T();
void Tprime();
void F();


void match(char c) {
    if (input[i] == c)
        i++;
    else {
        printf("Error at %c\n", input[i]);
        
    }
}


void E() {
    T();
    Eprime();
}


void Eprime() {
    if (input[i] == '+') {
        match('+');
        T();
        Eprime();
    }
    // else epsilon
}


void T() {
    F();
    Tprime();
}


void Tprime() {
    if (input[i] == '*') {
        match('*');
        F();
        Tprime();
    }
    // else epsilon
}


void F() {
    if (input[i] == '(') {
        match('(');
        E();
        match(')');
    }
    else if (isalpha(input[i])) {  // id
        match(input[i]);
    }
    else {
        printf("Invalid character: %c\n", input[i]);
        
    }
}


int main() {
    printf("Enter Expression: ");
    scanf("%s", input);


    E();


    if (input[i] == '\0')
        printf("Parsing Successful!\n");
    else
        printf("Parsing Failed!\n");


    return 0;
}


Output : 
Enter Expression: a*a+a
Parsing Successful!










5. write recursive descent parser for the grammar S->(L) S->a L->L,S L->S              Final grammar used in the code:


S  → a | ( L )
L  → S L'
L' → , S L' | ε          #include <stdio.h>
#include <string.h>
#include <stdlib.h>


char input[100];
int pos = 0;


/* Function declarations */
void S();
void L();
void Ldash();


/* Match a specific character */
void match(char c) {
    if (input[pos] == c)
        pos++;
    else {
        printf("\nError: Expected '%c'\n", c);
        exit(0);
    }
}


/* S → a | ( L ) */
void S() {
    if (input[pos] == 'a') {
        match('a');
    }
    else if (input[pos] == '(') {
        match('(');
        L();
        match(')');
    }
    else {
        printf("\nError in S\n");
        exit(0);
    }
}


/* L → S L' */
void L() {
    S();
    Ldash();
}


/* L' → , S L' | ε */
void Ldash() {
    if (input[pos] == ',') {
        match(',');
        S();
        Ldash();
    }
    // else epsilon — do nothing
}


int main() {
    printf("Enter input string: ");
    scanf("%s", input);


    S();


    if (input[pos] == '\0')
        printf("\n✔ Parsing Successful! The string is valid.\n");
    else
        printf("\n❌ Parsing Failed! Extra characters found.\n");


    return 0;
}




3. Write a C program to construct predictive parser for the following grammar
E->TR
R->+TR/Î
T->FP
T->*FP/Î
F->a/(E)


#include<stdio.h>
#include<process.h>
#include<conio.h>


char stack[20];
int top = -1;


void push(char c) {
    stack[++top] = c;
}


char pop() {
    return stack[top--];
}


void error() {
    printf("Parsing is not successful");
    exit(0);
}


void main()
{
    char str[20], ch;
    int ip = 0;






    printf("Enter string ending with $: ");
    scanf("%s", str);


    push('$');
    push('E');


    while (1)
    {
        ch = pop();


        if (ch == '$')
        {
            if (str[ip] == '$')
            {
                printf("Parsing is successful");
                getch();
                return;
            }
            else
                error();
        }


        switch (ch)
        {
            case 'E':
                if (str[ip] == 'a' || str[ip] == '(')
                {
                    push('R');
                    push('T');
                }
                else error();
                break;


            case 'R':
                if (str[ip] == '+')
                {
                    push('R');
                    push('T');
                    push('+');
                }
                else if (str[ip] == ')' || str[ip] == '$')
                {
                    // epsilon production
                }
                else error();
                break;


            case 'T':
                if (str[ip] == 'a' || str[ip] == '(')
                {
                    push('P');
                    push('F');
                }
                else error();
                break;


            case 'P':
                if (str[ip] == '*')
                {
                    push('P');
                    push('F');
                    push('*');
                }
                else if (str[ip] == '+' || str[ip] == ')' || str[ip] == '$')
                {
                    // epsilon production
                }
                else error();
                break;


            case 'F':
                if (str[ip] == 'a')
                    push('a');
                else if (str[ip] == '(')
                {
                    push(')');
                    push('E');
                    push('(');
                }
                else error();
                break;


            case '+':
                if (str[ip] == '+') ip++;
                else error();
                break;


            case '*':
                if (str[ip] == '*') ip++;
                else error();
                break;


            case '(':
                if (str[ip] == '(') ip++;
                else error();
                break;


            case ')':
                if (str[ip] == ')') ip++;
                else error();
                break;


            case 'a':
                if (str[ip] == 'a') ip++;
                else error();
                break;


            default:
                error();
        }
    }
}




Output


a+a*a$
Parsing is successful


Output
a+*a$
Parsing is not successful










4. Write a Lex specification to recognize +ve integers,reals and -ve integers,reals.
%{
#include<stdio.h>
%}
%%
                "+"?[0-9]+                           {printf("%s:positive integers",yytext);}
                -[0-9]+                                 {printf("%s:negative integers",yytext);}
                -[0-9]+\.[0-9]+                    {printf("%s:negative real numbers",yytext);}
                "+"?[0-9]+\.[0-9]+      {printf("%s:positive real numbers",yytext);}
%%
main()
{
 yylex();
}
 
Compilation: lex noformat.l
                            cc lex.yy.c -ll
                            ./a.out
                            24
                            positive integer
                            +24.12
                            positive real number
                            -24
                            negative integer
                            -24.12
                            negative real number
                            
 
 5. Write a Lex specification for converting real numbers to integers.
%{
#include<stdio.h>
int i, j;
%}


%%
[0-9]*\.[0-9]+  {
                        for(i = 0; yytext[i] != '\0'; i++)
                  {
                      // When we find the decimal point
                      if(yytext[i] == '.')
                      {
                          // Print characters BEFORE decimal point
                          for(j = 0; j < i; j++)
                          {
                              printf("%c", yytext[j]);
                          }
                          printf("\n");
                          break;   // Stop after printing integer part
                      }
                  }
                }
%%


main() {
    yylex();
}
Compilation: lex realtoint.l
                            cc lex.yy.c -ll
                            ./a.out
                            24.12
                            24


 6.     Write a Lex specification to print the number of days in a month using a procedure
%{
    #include <stdio.h>
    int year;
    void leap();
%}


%%


jan|mar|may|jul|aug|oct|dec     { printf("31 days\n"); }
apr|jun|sep|nov                 { printf("30 days\n"); }
feb                             { leap(); }
[a-zA-Z]+                       { printf("invalid\n"); }


%%


int main()
{
    yylex();
    return 0;
}


void leap()
{
    printf("enter year: ");
    scanf("%d", &year);


    if ((year % 400 == 0) || (year % 4 == 0 && year % 100 != 0))
        printf("29 days\n");
    else
        printf("28 days\n");
}


Compilation: lex daysinamonth.l
                            cc lex.yy.c -ll
                            ./a.out
                            jan
                            31 days
                            june
                            30 days
                            feb
                            enter year
                            1984
                            29 days


Write a Lex specification to retrieve comments.
%{
    #include <stdio.h>
%}


%%


"//"[a-zA-Z0-9 ]*          { printf("%s\n", yytext); }


"/*"[a-zA-Z0-9 ]*"*/"      { printf("%s\n", yytext); }


/* Ignore all other text */
.|\n                       { /* ignore */ }


%%


int main()
{
    yylex();
    return 0;
}


Compilation: lex comments.l
                            cc lex.yy.c -ll
                            ./a.out
                            Hello //world
                            world
                            hai /*friend*/
                            friend
 


FROM SYLLABUS COPYY


1).Implementation of symbol table.
#include <stdio.h>
#include <stdlib.h>
#include <string.h>


#define MAX 100


struct SymbolTable
{
    char name[30];
    char type[10];
    int size;
    int address;
} st[MAX];


int count = 0;


void insert();
void display();
int search(char *);
void modify();
void deleteSymbol();


int main()
{
    int choice;
    char symbol[30];
    int result;


    while (1)
    {
        printf("\n\n==== SYMBOL TABLE MENU ====\n");
        printf("1. Insert\n");
        printf("2. Display\n");
        printf("3. Search\n");
        printf("4. Modify\n");
        printf("5. Delete\n");
        printf("6. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);


        switch (choice)
        {
        case 1:
            insert();
            break;
        case 2:
            display();
            break;
        case 3:
            printf("Enter symbol to search: ");
            scanf("%s", symbol);
            result = search(symbol);


            if (result == -1)
                printf("Symbol not found!\n");
            else
                printf("Symbol found at index %d\n", result);
            break;


        case 4:
            modify();
            break;
        case 5:
            deleteSymbol();
            break;
        case 6:
            exit(0);


        default:
            printf("Invalid choice!\n");
        }
    }


    return 0;
}


void insert()
{
    if (count >= MAX)
    {
        printf("Symbol table is full!\n");
        return;
    }


    printf("Enter symbol name: ");
    scanf("%s", st[count].name);


    if (search(st[count].name) != -1)
    {
        printf("Symbol already exists!\n");
        return;
    }


    printf("Enter type: ");
    scanf("%s", st[count].type);


    printf("Enter size: ");
    scanf("%d", &st[count].size);


    printf("Enter address: ");
    scanf("%d", &st[count].address);


    count++;
    printf("Symbol inserted successfully!\n");
}


void display()
{
    int i;


    if (count == 0)
    {
        printf("Symbol table is empty!\n");
        return;
    }


    printf("\n%-15s %-10s %-10s %-10s\n", "Name", "Type", "Size", "Address");
    printf("-------------------------------------------------------\n");


    for (i = 0; i < count; i++)
    {
        printf("%-15s %-10s %-10d %-10d\n",
               st[i].name, st[i].type, st[i].size, st[i].address);
    }
}


int search(char *name)
{
    int i;
    for (i = 0; i < count; i++)
    {
        if (strcmp(st[i].name, name) == 0)
            return i;
    }
    return -1;
}


void modify()
{
    char name[30];
    int index;


    printf("Enter symbol name to modify: ");
    scanf("%s", name);


    index = search(name);


    if (index == -1)
    {
        printf("Symbol not found!\n");
        return;
    }


    printf("Enter new type: ");
    scanf("%s", st[index].type);


    printf("Enter new size: ");
    scanf("%d", &st[index].size);


    printf("Enter new address: ");
    scanf("%d", &st[index].address);


    printf("Symbol modified successfully!\n");
}


void deleteSymbol()
{
    char name[30];
    int index, i;


    printf("Enter symbol name to delete: ");
    scanf("%s", name);


    index = search(name);


    if (index == -1)
    {
        printf("Symbol not found!\n");
        return;
    }


    for (i = index; i < count - 1; i++)
    {
        st[i] = st[i + 1];
    }


    count--;
    printf("Symbol deleted successfully!\n");
}


Sample Output
==== SYMBOL TABLE MENU ====
1. Insert
2. Display
3. Search
4. Modify
5. Delete
6. Exit
Enter your choice: 1
Enter symbol name: x
Enter type (int/float/char): int
Enter size: 4
Enter address: 100
Symbol inserted successfully!




==== SYMBOL TABLE MENU ====
2
Name            Type       Size       Address   
-------------------------------------------------------
x               int        4          100




2)Develop a lexical analyzer to recognize a few patterns inc (ex. Identifiers, constants, comments, operators etc.)
#include <stdio.h>
#include <string.h>
#include <ctype.h>


char keywords[32][10] = {
    "auto","break","case","char","const","continue","default","do",
    "double","else","enum","extern","float","for","goto","if",
    "int","long","register","return","short","signed","sizeof","static",
    "struct","switch","typedef","union","unsigned","void","volatile","while"
};


int isKeyword(char *str) {
    int i;
    for (i = 0; i < 32; i++) {
        if (strcmp(keywords[i], str) == 0)
            return 1;
    }
    return 0;
}


int isOperator(char ch) {
    return (ch=='+' || ch=='-' || ch=='*' || ch=='/' ||
            ch=='=' || ch=='<' || ch=='>' || ch=='!' ||
            ch=='&' || ch=='|' || ch=='%');
}


int isDelimiter(char ch) {
    return (ch==',' || ch=='(' || ch==')' || ch=='{' || ch=='}' ||
            ch=='[' || ch==']' || ch==';' || ch==' ' || ch=='\n' || ch=='\t');
}


void analyze(char *input) {
    int i = 0;


    while (input[i] != '\0') {
        char ch = input[i];


        /* -------- COMMENTS ---------- */
        if (ch == '/' && input[i+1] == '/') {
            printf("[COMMENT]: ");
            i += 2;
            while (input[i] != '\n' && input[i] != '\0') {
                putchar(input[i]);
                i++;
            }
            printf("\n");
            continue;
        }


        /* -------- OPERATORS ---------- */
        if (isOperator(ch)) {
            printf("[OPERATOR]: %c\n", ch);
            i++;
            continue;
        }


        /* -------- DELIMITERS ---------- */
        if (isDelimiter(ch)) {
            if (ch != ' ' && ch != '\n' && ch != '\t')
                printf("[DELIMITER]: %c\n", ch);
            i++;
            continue;
        }


        /* -------- IDENTIFIERS / KEYWORDS ---------- */
        if (isalpha(ch) || ch == '_') {
            char buffer[50];
            int j = 0;


            while (isalnum(input[i]) || input[i] == '_')
                buffer[j++] = input[i++];


            buffer[j] = '\0';


            if (isKeyword(buffer))
                printf("[KEYWORD]: %s\n", buffer);
            else
                printf("[IDENTIFIER]: %s\n", buffer);
            continue;
        }


        /* -------- INTEGER CONSTANTS ---------- */
        if (isdigit(ch)) {
            char buffer[50];
            int j = 0;


            while (isdigit(input[i]))
                buffer[j++] = input[i++];


            buffer[j] = '\0';
            printf("[CONSTANT]: %s\n", buffer);
            continue;
        }


        i++;
    }
}


int main() {
    char code[] = "int x = 10; //start\nif (x > 5) { return x; }";


    printf("--- INPUT CODE ---\n%s\n", code);
    printf("\n--- OUTPUT TOKENS ---\n");
    analyze(code);


    return 0;
}


OUTPUT:
--- INPUT CODE ---
int x = 10; //start  
if (x > 5) { return x; }


--- OUTPUT TOKENS ---
[KEYWORD]: int
[IDENTIFIER]: x
[OPERATOR]: =
[CONSTANT]: 10
[DELIMITER]: ;
[COMMENT]: start
[KEYWORD]: if
[DELIMITER]: (
[IDENTIFIER]: x
[OPERATOR]: >
[CONSTANT]: 5
[DELIMITER]: )
[DELIMITER]: {
[KEYWORD]: return
[IDENTIFIER]: x
[DELIMITER]: ;
[DELIMITER]: }


 
3. Implementation of lexical analyzer using lex tool.
%{
#include <stdio.h>
%}


%%


/\*([^*]|\*+[^*/])*\*+/       { printf("Multi-line Comment: %s\n", yytext); }


/\/\/.*                      { printf("Single-line Comment: %s\n", yytext); }


/* KEYWORDS (case-insensitive) */
(?i:if|else|while|do|switch|case|break|for|default)   {
                        printf("Keyword: %s\n", yytext);
                    }


/* IDENTIFIERS */
[a-zA-Z_][a-zA-Z0-9_]*       { printf("Identifier: %s\n", yytext); }


/* INTEGER CONSTANTS */
[0-9]+                       { printf("Integer Constant: %s\n", yytext); }


/* FLOAT CONSTANTS */
[0-9]*\.[0-9]+               { printf("Float Constant: %s\n", yytext); }


/* OPERATORS */
"=="|"="|"+"|"-"|"*"|"/"     { printf("Operator: %s\n", yytext); }


/* DELIMITERS */
[{}();,:]                    { printf("Delimiter: %s\n", yytext); }


/* Ignore whitespace */
[ \t\n]+                     { /* ignore */ }


/* Anything else → unknown token */
.                            { printf("Unknown: %s\n", yytext); }


%%


int main() {
    yylex();
    return 0;
}


Compilation: lex lexanalysis.l
                                               cc lex.yy.c -ll
                                               ./a.out




. Implement type checking




#include <stdio.h>
#include <string.h>


char names[20][20];
char types[20][10];
int n = 0;


void add(char v[], char t[]) {
    strcpy(names[n], v);
    strcpy(types[n], t);
    n++;
}


char* get(char v[]) {
    for(int i=0;i<n;i++)
        if(strcmp(names[i], v)==0)
            return types[i];
    return NULL;
}


int main() {
    char v1[20], v2[20], op[5], t1[10];


    int ch;
    while(1) {
        printf("\n1.Declare  2.Check  3.Table  4.Exit : ");
        scanf("%d",&ch);


        if(ch==1) {
            printf("Var name: "); scanf("%s", v1);
            printf("Type: ");     scanf("%s", t1);
            add(v1, t1);
            printf("Declared Successfully!\n");
        }


        else if(ch==2) {
            printf("Enter expression (a + b): ");
            scanf("%s %s %s", v1, op, v2);


            char *t1 = get(v1);
            char *t2 = get(v2);


            if(!t1 || !t2) {
                printf(" Error: Undeclared variable!\n");
                continue;
            }


            if((strcmp(op,"+")==0 || strcmp(op,"-")==0 ||
                strcmp(op,"*")==0 || strcmp(op,"/")==0) &&
               ((strcmp(t1,"int")==0 || strcmp(t1,"float")==0) &&
                (strcmp(t2,"int")==0 || strcmp(t2,"float")==0))) {


                printf("Type Check Passed! Result type = %s\n",
                       (strcmp(t1,"float")==0 || strcmp(t2,"float")==0) ? "float" : "int");
            }
            else {
                printf("? Type Error!\n");
            }
        }


        else if(ch==3) {
            printf("\nNAME\tTYPE\n");
            for(int i=0;i<n;i++)
                printf("%s\t%s\n", names[i], types[i]);
        }


        else break;
    }
    return 0;
}


Output : 
1.Declare  2.Check  3.Table  4.Exit : 1
Var name: x
Type: int
 Declared Successfully!


1.Declare  2.Check  3.Table  4.Exit : 2
Enter expression (a + b): x + x
 Type Check Passed! Result type = int












9. Implement any one storage allocation strategies (heap, stack,static)


#include <stdio.h>
#include <string.h>


int sp = 0;  // stack pointer
char name[20][20], type[20][10];
int sizeArr[20], offset[20];
int n = 0;


int getSize(char t[]) {
    if(!strcmp(t,"int") || !strcmp(t,"float")) return 4;
    if(!strcmp(t,"char")) return 1;
    if(!strcmp(t,"double")) return 8;
    return 4;
}


void allocate(char v[], char t[]) {
    int s = getSize(t);


    if(sp + s > 1000) {
        printf("❌ Stack Overflow!\n");
        return;
    }


    strcpy(name[n], v);
    strcpy(type[n], t);
    sizeArr[n] = s;
    offset[n] = sp;


    sp += s;
    n++;


    printf("✔ Allocated %d bytes for %s at offset %d\n", s, v, offset[n-1]);
}


void deallocate() {
    if(n == 0) { 
        printf("❌ Stack Underflow!\n");
        return;
    }


    n--;
    sp -= sizeArr[n];


    printf("✔ Deallocated %s (%d bytes)\n", name[n], sizeArr[n]);
}


void display() {
    if(n == 0) {
        printf("Stack Empty!\n");
        return;
    }


    printf("\nVar\tType\tSize\tOffset\n");
    for(int i=0;i<n;i++)
        printf("%s\t%s\t%d\t%d\n", name[i], type[i], sizeArr[i], offset[i]);


    printf("Current SP = %d\n", sp);
}


int main() {
    int ch;
    char v[20], t[10];


    while(1) {
        printf("\n1.Allocate 2.Deallocate 3.Display 4.Exit : ");
        scanf("%d",&ch);


        if(ch==1) {
            printf("Name: "); scanf("%s", v);
            printf("Type: "); scanf("%s", t);
            allocate(v, t);
        }
        else if(ch==2) deallocate();
        else if(ch==3) display();
        else break;
    }
    return 0;
}






Output 👍




1.Allocate 2.Deallocate 3.Display 4.Exit : 1
Name: x
Type: int
? Allocated 4 bytes for x at offset 0


1.Allocate 2.Deallocate 3.Display 4.Exit : 1
Name: double
Type: double
? Allocated 8 bytes for double at offset 4


1.Allocate 2.Deallocate 3.Display 4.Exit : 3


Var     Type    Size    Offset
x       int     4       0
double  double  8       4
Current SP = 12










12)Write a lex program to count the number of words and number of lines in a given file or program.
%{
#include <stdio.h>


int wordCount = 0;
int lineCount = 0;
%}


%%


\n              { lineCount++; }
[ \t]+          { /* ignore spaces/tabs */ }
[a-zA-Z0-9_]+   { wordCount++; }
.               { /* ignore other characters */ }


%%


int main() {
    yylex();
    printf("\nTotal Lines : %d\n", lineCount);
    printf("Total Words : %d\n", wordCount);
    return 0;
}


Compilation:
lex wordcount.l          
cc lex.yy.c -ll -o wordcount  
./wordcount                      
 
OUPUT:
$ ./wordcount
Enter text:
Hello world
This is a test
<Ctrl-D>
 
Number of lines: 2
Number of words: 6